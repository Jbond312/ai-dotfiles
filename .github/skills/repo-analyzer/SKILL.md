---
name: repo-analyzer
description: 'Analyze repository structure and discover coding conventions. Use before starting work on a new repository, when conventions file is missing, or when asked to "discover conventions", "analyze repo", or "what patterns does this repo use". Generates .planning/CONVENTIONS.md.'
---

# Repository Analyzer

Discovers coding conventions, patterns, and structure from an existing codebase. Outputs findings to `.planning/CONVENTIONS.md` for other skills to reference.

## When to Run

- First time working in a repository
- When `.planning/CONVENTIONS.md` doesn't exist
- When explicitly asked to refresh conventions
- After major refactoring or architecture changes

## Analysis Process

### Step 1: Project Structure

Examine the solution and project files:

```bash
# Find solution files
find . -name "*.sln" -type f

# Find project files and their types
find . -name "*.csproj" -type f -exec grep -l "Sdk=" {} \;
```

Document:

- Solution name and structure
- Project types (Web API, Class Library, Test, etc.)
- Layer organisation (if Clean Architecture, VSA, etc.)

### Step 2: Test Framework Discovery

```bash
# Check for test framework packages
grep -r "xunit\|nunit\|mstest" --include="*.csproj" .

# Find test files to analyse naming patterns
find . -name "*Tests.cs" -o -name "*Test.cs" | head -20
```

Examine 3-5 test files to determine:

- Framework: xUnit / NUnit / MSTest
- Naming convention: `MethodName_Condition_ExpectedResult` / `Should_X_When_Y` / other
- Assertion library: FluentAssertions / Shouldly / framework built-in
- Mocking library: Moq / NSubstitute / FakeItEasy / none
- Test organisation: one class per SUT / feature-based / other

### Step 3: Handler/Mediator Pattern

```bash
# Check for MediatR
grep -r "MediatR\|IRequest\|IRequestHandler" --include="*.csproj" --include="*.cs" . | head -10

# Check for custom handlers
find . -name "*Handler.cs" -o -name "*CommandHandler.cs" -o -name "*QueryHandler.cs" | head -10
```

Document:

- MediatR / custom handlers / direct service calls
- Command/Query separation (CQRS) or combined
- Handler location pattern

### Step 4: Mapping Approach

```bash
# Check for mapping libraries
grep -r "AutoMapper\|Mapster" --include="*.csproj" .

# Check for static mapping methods
grep -r "static.*Map\|ToDto\|ToEntity\|ToModel" --include="*.cs" . | head -10
```

Document:

- AutoMapper / Mapster / static extension methods / manual mapping
- Mapping location (in handlers, separate classes, extensions)

### Step 5: Error Handling Pattern

```bash
# Check for Result types
grep -r "Result<\|ErrorOr\|OneOf\|FluentResults" --include="*.cs" . | head -10

# Check exception patterns
grep -r "throw new\|catch\s*(" --include="*.cs" . | head -20
```

Document:

- Result/ErrorOr pattern vs exceptions
- Custom exception types
- Validation approach (FluentValidation, DataAnnotations, manual)

### Step 6: Logging and Observability

```bash
# Check logging framework
grep -r "Serilog\|NLog\|ILogger" --include="*.csproj" --include="*.cs" . | head -10
```

Document:

- Logging framework
- Structured logging patterns
- Correlation ID usage

### Step 7: Code Style Patterns

Examine 3-5 representative files to identify:

- Nullable reference types enabled?
- Primary constructors used?
- File-scoped namespaces?
- Record types for DTOs?
- Expression-bodied members preference?

## Output Format

Create `.planning/CONVENTIONS.md` with this structure:

````markdown
# Repository Conventions

> Auto-generated by repo-analyzer. Last updated: {date}
> Re-run analysis if conventions have changed significantly.

## Project Structure

| Aspect        | Convention                                                      |
| ------------- | --------------------------------------------------------------- |
| Architecture  | {e.g., Vertical Slice Architecture, Clean Architecture, N-tier} |
| Solution      | {solution name and key projects}                                |
| Test Projects | {naming pattern, e.g., ProjectName.Tests}                       |

## Testing Conventions

| Aspect       | Convention                               |
| ------------ | ---------------------------------------- |
| Framework    | {xUnit / NUnit / MSTest}                 |
| Assertions   | {FluentAssertions / Shouldly / built-in} |
| Mocking      | {Moq / NSubstitute / none}               |
| Naming       | {pattern with example}                   |
| Organisation | {one test class per SUT / feature-based} |

### Test Naming Examples

```csharp
// From: {actual file path}
{actual test method signature from repo}
```
````

## Handler Pattern

| Aspect   | Convention                                    |
| -------- | --------------------------------------------- |
| Style    | {MediatR / custom handlers / direct services} |
| CQRS     | {yes / no}                                    |
| Location | {where handlers live}                         |

### Handler Example

```csharp
// From: {actual file path}
{simplified handler structure}
```

## Mapping

| Aspect   | Convention                                         |
| -------- | -------------------------------------------------- |
| Approach | {AutoMapper / Mapster / static methods / manual}   |
| Location | {in handlers / extension methods / mapper classes} |

## Error Handling

| Aspect     | Convention                                    |
| ---------- | --------------------------------------------- |
| Style      | {Result<T> / exceptions / ErrorOr}            |
| Validation | {FluentValidation / DataAnnotations / manual} |

## Code Style

| Aspect               | Convention                   |
| -------------------- | ---------------------------- |
| Nullable             | {enabled / disabled}         |
| Namespaces           | {file-scoped / block-scoped} |
| Records              | {used for DTOs / not used}   |
| Primary Constructors | {used / not used}            |

## External Dependencies

{List any external APIs, databases, message queues discovered}

## Notes

{Any unusual patterns or deviations worth noting}

```

## Integration

After generating CONVENTIONS.md:
1. Inform the user what was discovered
2. Highlight any ambiguous patterns that need clarification
3. Suggest the file be reviewed and committed if conventions are stable
```

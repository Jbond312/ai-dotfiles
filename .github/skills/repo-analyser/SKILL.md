---
name: repo-analyser
description: 'Discover repository conventions and patterns. Use when conventions file is missing, before starting work on a new repository, or when asked to "discover conventions", "analyse repo", or "what patterns does this repo use". Generates .planning/CONVENTIONS.md.'
---

# Repository Analyser

Discovers how a repository works — its architecture, patterns, conventions, and dependencies. The goal is to understand "how things are done here" so agents can follow existing practices.

**Note:** This skill is primarily used via the `Repo Analyser` agent as a subagent. The content here serves as reference documentation.

## Philosophy

**Discover, don't assume.** Every repository has its own conventions. Rather than looking for specific frameworks, observe what patterns actually exist and document them. If something is unclear, note it as "unclear" rather than guessing.

## When to Run

- First time working in a repository
- When `.planning/CONVENTIONS.md` doesn't exist
- When explicitly asked to refresh conventions

## Cross-Platform Commands

**Use your `search` and `read` tools** for all codebase exploration. Only use the terminal for `dotnet` and `git` commands — these work identically across all shells.

## Discovery Process

Work through each section. For each, explore the codebase and document what you find.

### 1. Solution Overview

Use `search` to find `*.sln` and `*.csproj` files. Use `read` to examine project files for `<TargetFramework>` values.

```
dotnet sln list
```

**Document:**
- Solution name
- Number and types of projects
- .NET version(s) in use

### 2. Architecture Pattern

Use `search` to explore the folder structure and find directories named `Domain`, `Application`, `Infrastructure`, `Features`, `Handlers`, `Ports`, `Adapters`, `Services`, `Repositories`, `Controllers`.

**Look for signals:**

| Pattern | Signals |
|---------|---------|
| **Vertical Slice Architecture** | `/Features/` folders, handlers grouped by feature, minimal layering |
| **Clean Architecture** | `/Domain/`, `/Application/`, `/Infrastructure/`, `/Presentation/` separation |
| **Hexagonal (Ports & Adapters)** | `/Ports/`, `/Adapters/`, clear interface boundaries |
| **N-Tier / Layered** | `/Services/`, `/Repositories/`, `/Controllers/` at same level |
| **Minimal / Simple** | Flat structure, few abstractions |

**Document:** The pattern you observe, or "unclear/mixed" if it doesn't fit neatly.

### 3. External Dependencies

Use `search` to find `*.csproj` files, then `read` them and look for `PackageReference` entries related to: EntityFramework, Dapper, Npgsql, SqlClient, Azure, RabbitMQ, MassTransit, Kafka, Redis, MongoDB.

Also use `search` to look for references to `ConnectionString`, `ServiceBus`, `BlobStorage`, `CosmosDb` in `.json` and `.cs` files.

**Document:**
- Databases (SQL Server, PostgreSQL, CosmosDB, etc.)
- Message brokers (Azure Service Bus, RabbitMQ, Kafka)
- External APIs or services
- Cloud services (Azure Storage, AWS S3, etc.)

### 4. Testing Approach

Use `search` to find test projects (`*Tests*.csproj`, `*Test*.csproj`) and test files (`*Tests.cs`, `*Test.cs`).

**Use `read` to examine 3-5 actual test files** and understand:
- Test class naming (e.g., `{ClassName}Tests`, `{Feature}Tests`)
- Test method naming (e.g., `MethodName_Condition_Result`, `Should_X_When_Y`)
- Assertion style (FluentAssertions, Shouldly, built-in)
- Mocking approach (Moq, NSubstitute, hand-written fakes)
- Test organisation (one class per SUT, feature-based, behaviour-based)

**Document with actual examples** from the codebase.

### 5. Code Patterns

Use `search` to find `*Handler.cs`, `*Command.cs`, `*Query.cs` files. Use `search` to look for references to `MediatR`, `Wolverine`, `Result<`, `ErrorOr`, `FluentValidation`, `AutoMapper`, `Mapster`.

**Use `read` to examine 3-5 representative files** and understand:

| Aspect | What to Look For |
|--------|------------------|
| **Request handling** | MediatR, Wolverine, custom handlers, direct controller logic |
| **Validation** | FluentValidation, DataAnnotations, manual checks |
| **Error handling** | Result/ErrorOr types, exceptions, custom error types |
| **Mapping** | AutoMapper, Mapster, manual mapping, extension methods |
| **Dependency injection** | Constructor injection, how dependencies are organised |

### 6. Code Style

Use `read` to examine a few production `.cs` files (in `src/`) for:
- Nullable reference types (`#nullable enable`, `?` on types)
- File-scoped vs block-scoped namespaces
- Primary constructors
- Record types for DTOs
- Expression-bodied members
- Naming conventions (e.g., `_fieldName`, `FieldName`)

### 7. Anything Else Notable

Note anything unusual or project-specific:
- Custom base classes or utilities
- Domain-specific patterns
- Unusual folder structures
- Build or deployment conventions

## Output Format

Create `.planning/CONVENTIONS.md`:

```markdown
# Repository Conventions

> Generated by repo-analyser on {date}
> Review and adjust if needed. Re-run if conventions change significantly.

## Overview

| Aspect | Value |
|--------|-------|
| Solution | {name} |
| .NET Version | {version} |
| Architecture | {pattern or "unclear"} |
| Test Framework | {framework} |
| Key Packages | {e.g., FluentValidation 11.x, MediatR 12.x} |

## Architecture

{Description of the architectural pattern observed, with folder structure examples}

## Project Structure

```
src/
├── {ProjectName}/
│   ├── {TopLevelFolder}/       # {purpose}
│   │   └── {ExampleSubfolder}/
│   │       ├── {ExampleFile}.cs
│   │       └── ...
│   └── ...
tests/
├── {ProjectName}.Tests/
│   └── {MirroredStructure}/
│       └── {ExampleTestFile}.cs
```

## External Dependencies

| Type | Technology | Notes |
|------|------------|-------|
| Database | {e.g., SQL Server via EF Core} | {any notes} |
| Messaging | {e.g., Azure Service Bus} | {any notes} |
| ... | ... | ... |

## Testing Conventions

| Aspect | Convention |
|--------|------------|
| Framework | {xUnit/NUnit/MSTest} |
| Assertions | {FluentAssertions/Shouldly/built-in} |
| Mocking | {Moq/NSubstitute/none} |
| Test naming | {pattern} |
| Organisation | {description} |

### Example Test

```csharp
// From: {actual file path}
{actual test method showing naming and structure}
```

## Code Patterns

| Aspect | Pattern |
|--------|---------|
| Request handling | {MediatR/custom handlers/direct/etc.} |
| Validation | {FluentValidation/DataAnnotations/manual} |
| Error handling | {Result type/exceptions/etc.} |
| Mapping | {AutoMapper/Mapster/manual/extensions} |
| API style | {Controllers / Minimal APIs / mixed} |
| Data access | {Dapper raw / Dapper.Contrib / EF Core / mixed} |

### Example Handler/Service

```csharp
// From: {actual file path}
{simplified example showing typical structure}
```

### Example Error Handling

```csharp
// From: {actual file path}
{actual example showing Result<T> vs exception usage}
```

## Code Style

| Aspect | Convention |
|--------|------------|
| Nullable refs | {enabled/disabled} |
| Namespaces | {file-scoped/block-scoped} |
| Records | {used for X/not used} |
| Field naming | {_camelCase/other} |

## Notes

{Anything unusual, unclear, or worth highlighting}

---

## For Agents

**Critical rules when writing code in this repository:**

1. **Architecture:** Place new features in `{path pattern}` following {pattern}
2. **Error handling:** Use `{Result<T> | exceptions}` — see Example Error Handling above
3. **Test naming:** `{pattern}` — see Example Test above
4. **Assertions:** Use `{assertion library}` syntax
5. **New files:** Follow the folder structure in Project Structure above
6. **API style:** Use `{Controllers | Minimal APIs}` — see existing endpoints for reference
7. **Data access:** Use `{Dapper pattern}` — see existing repositories/queries for reference
```

## After Generation

1. Briefly summarise what was discovered
2. Highlight anything ambiguous that might need human clarification
3. The file is ready for agents to reference
